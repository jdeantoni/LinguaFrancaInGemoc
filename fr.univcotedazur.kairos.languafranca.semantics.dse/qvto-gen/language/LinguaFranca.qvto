import org.eclipse.gemoc.moccml_mapping.EclQVToHelper;
modeltype Ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
	modeltype inMM1 uses 'http://www.eclipse.org/emf/2002/Ecore';
	modeltype inMM2 uses 'http://www.icyphy.org/LinguaFranca';

modeltype QVT 		uses 'http://www.eclipse.org/QVT/1.0.0/Operational';
modeltype TimeModel uses 'http://fr.inria.aoste.timemodel';
modeltype FeedBack 	uses 'http://timesquare.inria.fr/feedback';
modeltype Priority  uses 'http://fr.inria.aoste.timesquare.ccslkernel.solver.priorities';

transformation doplatform__resource_org_icyphy_linguafranca_model_generated_LinguaFranca_ecore_To_CCSL(in inM : inMM2, out ccsl : TimeModel, out feedback : FeedBack, out priority: Priority);

property thePrioritySpec		:Priority::PrioritySpecification = null;
property theFeedBackSpec		:FeedBack::ActionModel = null;
property seqOfMSE :	Sequence(FeedBack::ModelSpecificEvent)    = Sequence{};
property theCCSLSpec			:TimeModel::CCSLModel::ClockConstraintSystem = null;
property theMainBlock			:TimeModel::CCSLModel::Block				 = null;
property Kernel_Integer 	: TimeModel::BasicType::Type		= null;
property Kernel_Clock_Type 	: TimeModel::BasicType::Type		= null;
property seqOfRelationDeclaration :	Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration)    = Sequence{};
property seqOfAbstractEntity :		Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)    = Sequence{};
property seqOfExpressionDeclaration :	Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration)    = Sequence{};
property allVarDefs : Sequence(String) = Sequence{}; 

query identifyUserRelations() {
	var kernelTypes :  	Sequence(TimeModel::BasicType::Type) := Sequence{};
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::BasicType::Type];
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::BasicType::Type];
	seqOfRelationDeclaration		+= getLibObjects("platform:/resource/fr.univcotedazur.kairos.linguafranca.semantics.moclib/mocc/LinguaFrancaUtils.moccml")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/resource/fr.univcotedazur.kairos.linguafranca.semantics.moclib/mocc/LinguaFrancaUtils.moccml")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/resource/fr.univcotedazur.kairos.linguafranca.semantics.moclib/mocc/LinguaFrancaUtils.moccml")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/resource/fr.univcotedazur.kairos.linguafranca.semantics.moclib/mocc/LinguaFrancaUtils.moccml")[TimeModel::BasicType::Type];

	Kernel_Integer 					:= kernelTypes[name='int']->asSequence()->first();
	Kernel_Clock_Type				:= kernelTypes[name='clock']->asSequence()->first();	
	return;
}


//usefull function :)
	mapping Real::Real2Integer(n: String) :TimeModel::BasicType::IntegerElement {
		name:= n;
		type:= Kernel_Integer;
		value := self.round();

		end{
			theMainBlock.elements += result;
		}
	}

main() {
	identifyUserRelations();
	inM.rootObjects()[inMM2::Model]->asSequence()->first()-> map ecore2CCSL();
	inM.rootObjects()[inMM2::Model]->asSequence()->first()-> map ecore2FeedBack();
	inM.rootObjects()[inMM2::Model]->asSequence()->first()-> map ecore2Priority();
}

			
	mapping inMM2::Model::ecore2CCSL() : TimeModel::CCSLModel::ClockConstraintSystem {
	    theCCSLSpec := result;
	    name := getNameOrUID(self.oclAsType(EObject));
	    theMainBlock :=object TimeModel::CCSLModel::Block{
	    	name := "mainBlock";
	    };
	    subBlock += theMainBlock;
	    result.superBlock := theMainBlock;
		
		var anEmptyBlock :=object TimeModel::CCSLModel::Block{
	    	name := "emptyBlock";
	    };
	    subBlock += anEmptyBlock;
		
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib';
			alias := 'kernel';
			
		}; 
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib';
			alias := 'CCSL';
			
		}; 
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/resource/fr.univcotedazur.kairos.linguafranca.semantics.moclib/mocc/LinguaFrancaUtils.moccml';
			alias := 'LinguaFrancaUtils';
			
		}; 
	
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};

		

		


		

		////[ Model ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map timeJump2Clock();
		////[ Model ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map untimedAction2Clock();
		////[ Model ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map allTimerAndActionRelease2Clock();
		////[ Model ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map allCanRelease2Clock();
		////[ Model ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map allWait2Clock();
		


		

		////[ Instantiation ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Instantiation.oclAsType(EClass)).oclAsType(Instantiation)->map startExecuting2Clock();
		////[ Instantiation ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Instantiation.oclAsType(EClass)).oclAsType(Instantiation)->map finishExecuting2Clock();
		


		

		////[ Reactor ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Reactor.oclAsType(EClass)).oclAsType(Reactor)->map startExecuting2Clock();
		////[ Reactor ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Reactor.oclAsType(EClass)).oclAsType(Reactor)->map finishExecuting2Clock();
		


		

		////[ Reaction ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Reaction.oclAsType(EClass)).oclAsType(Reaction)->map synchronousExecution2Clock();
		


		

		////[ Variable ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Variable.oclAsType(EClass)).oclAsType(Variable)->map updates2Clock();
		


		

		////[ Timer ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Timer.oclAsType(EClass)).oclAsType(Timer)->map starts2Clock();
		////[ Timer ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Timer.oclAsType(EClass)).oclAsType(Timer)->map releases2Clock();
		////[ Timer ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Timer.oclAsType(EClass)).oclAsType(Timer)->map wait2Clock();
		////[ Timer ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Timer.oclAsType(EClass)).oclAsType(Timer)->map canRelease2Clock();
		


		

		////[ Action ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map starts2Clock();
		////[ Action ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map releases2Clock();
		////[ Action ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map wait2Clock();
		////[ Action ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map canRelease2Clock();
		


		

		////[ Connection ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Connection.oclAsType(EClass)).oclAsType(Connection)->map starts2Clock();
		////[ Connection ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Connection.oclAsType(EClass)).oclAsType(Connection)->map releases2Clock();
		////[ Connection ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Connection.oclAsType(EClass)).oclAsType(Connection)->map wait2Clock();
		////[ Connection ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Connection.oclAsType(EClass)).oclAsType(Connection)->map canRelease2Clock();
		


		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map eitherTimedOrUntimed12eitherTimedOrUntimed();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map untimedPriorTimed2Exclusion12untimedPriorTimed2Exclusion();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map untimedPriorTimed3Exclusion12untimedPriorTimed3Exclusion();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Reaction.oclAsType(EClass)).oclAsType(Reaction)->map propagatesPrio112propagatesPrio1();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Port.oclAsType(EClass)).oclAsType(Port)->map propagatesPrio212propagatesPrio2();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Instantiation.oclAsType(EClass)).oclAsType(Instantiation)->map propagatesPrio312propagatesPrio3();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Instantiation.oclAsType(EClass)).oclAsType(Instantiation)->map propagatesPrio412propagatesPrio4();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Timer.oclAsType(EClass)).oclAsType(Timer)->map propagatesPrio512propagatesPrio5();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Timer.oclAsType(EClass)).oclAsType(Timer)->map propagatesPrio712propagatesPrio7();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Timer.oclAsType(EClass)).oclAsType(Timer)->map propagatesPrio912propagatesPrio9();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map propagatesPrio612propagatesPrio6();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map propagatesPrio822propagatesPrio8();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map propagatesPrio1022propagatesPrio10();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Connection.oclAsType(EClass)).oclAsType(Connection)->map propagatesPrio1122propagatesPrio11();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Connection.oclAsType(EClass)).oclAsType(Connection)->map propagatesPrio1222propagatesPrio12();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Connection.oclAsType(EClass)).oclAsType(Connection)->map propagatesPrio1322propagatesPrio13();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map onlyOneCanTickAtATime112onlyOneCanTickAtATime1();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map onlyOneCanTickAtATime212onlyOneCanTickAtATime2();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map onlyOneCanTickAtATime342onlyOneCanTickAtATime3();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map onlyOneReleaseAtATime112onlyOneReleaseAtATime1();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map onlyOneReleaseAtATime222onlyOneReleaseAtATime2();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map onlyOneReleaseAtATime342onlyOneReleaseAtATime3();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map onlyOneWaitAtATime112onlyOneWaitAtATime1();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map onlyOneWaitAtATime212onlyOneWaitAtATime2();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map onlyOneWaitAtATime342onlyOneWaitAtATime3();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map canReleasePriorReleaseExclusion12canReleasePriorReleaseExclusion();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map canReleasePriorWaitExclusion12canReleasePriorWaitExclusion();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map defUntimedAction132defUntimedAction();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map defUntimedActionNoAction132defUntimedActionNoAction();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map defAllCanRelease52defAllCanRelease();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map defAllCanReleaseNoAction52defAllCanReleaseNoAction();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map defAllTimerAndActionRelease52defAllTimerAndActionRelease();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map defAllTimerAndActionReleaseNoAction52defAllTimerAndActionReleaseNoAction();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map defAllWait52defAllWait();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map defAllWaitNoAction52defAllWaitNoAction();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Timer.oclAsType(EClass)).oclAsType(Timer)->map timerStartsWhenUpdates12timerStartsWhenUpdates();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Timer.oclAsType(EClass)).oclAsType(Timer)->map timerWaitOrRelease12timerWaitOrRelease();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Timer.oclAsType(EClass)).oclAsType(Timer)->map timerSetActionLifeCycle22timerSetActionLifeCycle();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map actionStartsWhenUpdates12actionStartsWhenUpdates();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map actionWaitOrRelease22actionWaitOrRelease();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map ActionSourceCoincidesTarget42ActionSourceCoincidesTarget();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map ActionSourceBeforeTarget42ActionSourceBeforeTarget();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map ActionTargetWhenReleased32ActionTargetWhenReleased();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map setActionLifeCycle42setActionLifeCycle();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map setNullLifeCycle22setNullLifeCycle();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Reactor.oclAsType(EClass)).oclAsType(Reactor)->map mainReactorStartNoInputInstanceWhenStartsPart122mainReactorStartNoInputInstanceWhenStartsPart1();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Reactor.oclAsType(EClass)).oclAsType(Reactor)->map mainReactorStartNoInputInstanceWhenStartsPart222mainReactorStartNoInputInstanceWhenStartsPart2();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Reactor.oclAsType(EClass)).oclAsType(Reactor)->map mainReactorNeverFinish22mainReactorNeverFinish();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Instantiation.oclAsType(EClass)).oclAsType(Instantiation)->map startComputeTimerOnly32startComputeTimerOnly();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Instantiation.oclAsType(EClass)).oclAsType(Instantiation)->map startComputeInputOnly32startComputeInputOnly();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Instantiation.oclAsType(EClass)).oclAsType(Instantiation)->map startComputeInputAndTimer52startComputeInputAndTimer();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Instantiation.oclAsType(EClass)).oclAsType(Instantiation)->map startInternalReactionWhenStart32startInternalReactionWhenStart();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Instantiation.oclAsType(EClass)).oclAsType(Instantiation)->map FinishInternalReactionWhenFinish32FinishInternalReactionWhenFinish();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Connection.oclAsType(EClass)).oclAsType(Connection)->map ConnectorSourceBeforeTarget22ConnectorSourceBeforeTarget();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Connection.oclAsType(EClass)).oclAsType(Connection)->map ConnectorSourceBeforeTargetTimed32ConnectorSourceBeforeTargetTimed();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Connection.oclAsType(EClass)).oclAsType(Connection)->map TimedConnectorStartsWithSource22TimedConnectorStartsWithSource();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Connection.oclAsType(EClass)).oclAsType(Connection)->map TimedConnectorReleaseWithTarget22TimedConnectorReleaseWithTarget();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Reaction.oclAsType(EClass)).oclAsType(Reaction)->map startWhenTheOnlyInputArrivedNoTimer32startWhenTheOnlyInputArrivedNoTimer();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Reaction.oclAsType(EClass)).oclAsType(Reaction)->map startWhenTheLastInputArrivedNoTimer42startWhenTheLastInputArrivedNoTimer();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Reaction.oclAsType(EClass)).oclAsType(Reaction)->map startWhenTheTimerRelease22startWhenTheTimerRelease();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Reaction.oclAsType(EClass)).oclAsType(Reaction)->map startWhenTheActionRelease22startWhenTheActionRelease();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Reaction.oclAsType(EClass)).oclAsType(Reaction)->map UpdatesOutVarAllTogether22UpdatesOutVarAllTogether();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Reaction.oclAsType(EClass)).oclAsType(Reaction)->map UpdatesOutVarOnExecute22UpdatesOutVarOnExecute();
		
	}





//create the expressions...

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate_allActionCanTick2Expression(an1 : Action, an2 : Action, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allActionCanTick'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_canRelease']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_canRelease']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate_allActionCanTick2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Action, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allActionCanTick'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_canRelease']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::allActionCanTick2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Action) := allActions->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allActionCanTick2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allActionCanTick2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allActionCanTick2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate_allTimerCanTick2Expression(an1 : Timer, an2 : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allTimerCanTick'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_canRelease']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_canRelease']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate_allTimerCanTick2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allTimerCanTick'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_canRelease']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::allTimerCanTick2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Timer) := allTimers->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allTimerCanTick2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allTimerCanTick2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allTimerCanTick2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate_allActionRelease2Expression(an1 : Action, an2 : Action, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allActionRelease'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_releases']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_releases']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate_allActionRelease2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Action, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allActionRelease'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_releases']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::allActionRelease2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Action) := allActions->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allActionRelease2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allActionRelease2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allActionRelease2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate_allTimerRelease2Expression(an1 : Timer, an2 : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allTimerRelease'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_releases']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_releases']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate_allTimerRelease2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allTimerRelease'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_releases']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::allTimerRelease2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Timer) := allTimers->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allTimerRelease2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allTimerRelease2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allTimerRelease2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate_allActionWait2Expression(an1 : Action, an2 : Action, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allActionWait'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_wait']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_wait']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate_allActionWait2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Action, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allActionWait'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_wait']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::allActionWait2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Action) := allActions->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allActionWait2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allActionWait2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allActionWait2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate_allTimerWait2Expression(an1 : Timer, an2 : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allTimerWait'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_wait']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_wait']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate_allTimerWait2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allTimerWait'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_wait']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::allTimerWait2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Timer) := allTimers->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allTimerWait2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allTimerWait2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allTimerWait2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	mapping inMM2::Model::union1_2_3_4_52Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_union1_2_3_4_5';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map union1_2_3_42Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allActionStarts2Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::union1_2_3_42Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_union1_2_3_4';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map union1_2_3Prime2Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allTimerStarts2Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::union1_2_3Prime2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_union1_2_3Prime';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map union1_2_32Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allFinishExecution2Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::union1_2_32Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_union1_2_3';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map union1_22Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allStartExecution2Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::union1_22Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_union1_2';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allSynchronousExecution2Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allUpdates2Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate_allActionStarts2Expression(an1 : Action, an2 : Action, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allActionStarts'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_starts']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_starts']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate_allActionStarts2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Action, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allActionStarts'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_starts']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::allActionStarts2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Action) := allActions->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allActionStarts2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allActionStarts2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allActionStarts2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate_allTimerStarts2Expression(an1 : Timer, an2 : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allTimerStarts'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_starts']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_starts']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate_allTimerStarts2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allTimerStarts'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_starts']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::allTimerStarts2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Timer) := allTimers->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allTimerStarts2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allTimerStarts2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allTimerStarts2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate_allFinishExecution2Expression(an1 : Instantiation, an2 : Instantiation, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allFinishExecution'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_finishExecuting']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_finishExecuting']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate_allFinishExecution2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Instantiation, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allFinishExecution'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_finishExecuting']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::allFinishExecution2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Instantiation) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Instantiation)).oclAsType(Instantiation)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allFinishExecution2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allFinishExecution2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allFinishExecution2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate_allStartExecution2Expression(an1 : Instantiation, an2 : Instantiation, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allStartExecution'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_startExecuting']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_startExecuting']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate_allStartExecution2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Instantiation, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allStartExecution'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_startExecuting']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::allStartExecution2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Instantiation) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Instantiation)).oclAsType(Instantiation)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allStartExecution2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allStartExecution2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allStartExecution2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate_allUpdates2Expression(an1 : Port, an2 : Port, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allUpdates'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_updates']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_updates']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate_allUpdates2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Port, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allUpdates'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_updates']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::allUpdates2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Port) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Port)).oclAsType(Port)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allUpdates2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allUpdates2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allUpdates2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate_allSynchronousExecution2Expression(an1 : Reaction, an2 : Reaction, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allSynchronousExecution'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_synchronousExecution']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_synchronousExecution']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate_allSynchronousExecution2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Reaction, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allSynchronousExecution'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_synchronousExecution']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::allSynchronousExecution2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Reaction) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Reaction)).oclAsType(Reaction)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allSynchronousExecution2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allSynchronousExecution2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allSynchronousExecution2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	mapping inMM2::Model::union21_2_3_4_52Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_union21_2_3_4_5';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map union21_2_3_42Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allTimedConnectionStarts22Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::union21_2_3_42Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_union21_2_3_4';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map union21_2_3Prime2Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allTimerStarts22Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::union21_2_3Prime2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_union21_2_3Prime';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map union21_2_32Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allFinishExecution22Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::union21_2_32Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_union21_2_3';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map union21_22Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allStartExecution22Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::union21_22Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_union21_2';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allSynchronousExecution22Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allUpdates22Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate_allTimedConnectionStarts22Expression(an1 : Connection, an2 : Connection, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allTimedConnectionStarts2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_starts']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_starts']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate_allTimedConnectionStarts22Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Connection, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allTimedConnectionStarts2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_starts']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::allTimedConnectionStarts22Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Connection) := allTimedConnections->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allTimedConnectionStarts22Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allTimedConnectionStarts22Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allTimedConnectionStarts22Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate_allTimerStarts22Expression(an1 : Timer, an2 : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allTimerStarts2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_starts']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_starts']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate_allTimerStarts22Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allTimerStarts2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_starts']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::allTimerStarts22Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Timer) := allTimers->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allTimerStarts22Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allTimerStarts22Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allTimerStarts22Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate_allFinishExecution22Expression(an1 : Instantiation, an2 : Instantiation, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allFinishExecution2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_finishExecuting']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_finishExecuting']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate_allFinishExecution22Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Instantiation, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allFinishExecution2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_finishExecuting']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::allFinishExecution22Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Instantiation) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Instantiation)).oclAsType(Instantiation)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allFinishExecution22Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allFinishExecution22Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allFinishExecution22Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate_allStartExecution22Expression(an1 : Instantiation, an2 : Instantiation, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allStartExecution2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_startExecuting']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_startExecuting']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate_allStartExecution22Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Instantiation, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allStartExecution2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_startExecuting']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::allStartExecution22Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Instantiation) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Instantiation)).oclAsType(Instantiation)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allStartExecution22Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allStartExecution22Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allStartExecution22Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate_allUpdates22Expression(an1 : Port, an2 : Port, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allUpdates2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_updates']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_updates']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate_allUpdates22Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Port, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allUpdates2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_updates']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::allUpdates22Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Port) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Port)).oclAsType(Port)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allUpdates22Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allUpdates22Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allUpdates22Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate_allSynchronousExecution22Expression(an1 : Reaction, an2 : Reaction, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allSynchronousExecution2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_synchronousExecution']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_synchronousExecution']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate_allSynchronousExecution22Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Reaction, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allSynchronousExecution2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_synchronousExecution']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::allSynchronousExecution22Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Reaction) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Reaction)).oclAsType(Reaction)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allSynchronousExecution22Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allSynchronousExecution22Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allSynchronousExecution22Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	mapping inMM2::Model::_allTimerAndActionCanRelease12Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union__allTimerAndActionCanRelease1';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map _allActionCanRelease12Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map _allTimerCanRelease12Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate__allTimerCanRelease12Expression(an1 : Timer, an2 : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate__allTimerCanRelease1'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_canRelease']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_canRelease']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate__allTimerCanRelease12Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate__allTimerCanRelease1'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_canRelease']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::_allTimerCanRelease12Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Timer) := allTimers->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate__allTimerCanRelease12Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate__allTimerCanRelease12Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate__allTimerCanRelease12Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate__allActionCanRelease12Expression(an1 : Action, an2 : Action, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate__allActionCanRelease1'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_canRelease']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_canRelease']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate__allActionCanRelease12Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Action, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate__allActionCanRelease1'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_canRelease']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::_allActionCanRelease12Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Action) := allActions->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate__allActionCanRelease12Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate__allActionCanRelease12Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate__allActionCanRelease12Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	mapping inMM2::Model::_allTimerAndConnectionCanRelease22Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union__allTimerAndConnectionCanRelease2';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map _allTimerCanRelease22Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map _allConnectionCanRelease22Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate__allConnectionCanRelease22Expression(an1 : Connection, an2 : Connection, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate__allConnectionCanRelease2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_canRelease']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_canRelease']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate__allConnectionCanRelease22Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Connection, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate__allConnectionCanRelease2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_canRelease']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::_allConnectionCanRelease22Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Connection) := allTimedConnections->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate__allConnectionCanRelease22Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate__allConnectionCanRelease22Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate__allConnectionCanRelease22Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate__allTimerCanRelease22Expression(an1 : Timer, an2 : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate__allTimerCanRelease2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_canRelease']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_canRelease']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate__allTimerCanRelease22Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate__allTimerCanRelease2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_canRelease']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::_allTimerCanRelease22Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Timer) := allTimers->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate__allTimerCanRelease22Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate__allTimerCanRelease22Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate__allTimerCanRelease22Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	mapping inMM2::Model::_allTimerAndActionRelease12Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union__allTimerAndActionRelease1';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map _allActionRelease12Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map _allTimerRelease12Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate__allTimerRelease12Expression(an1 : Timer, an2 : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate__allTimerRelease1'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_releases']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_releases']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate__allTimerRelease12Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate__allTimerRelease1'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_releases']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::_allTimerRelease12Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Timer) := allTimers->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate__allTimerRelease12Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate__allTimerRelease12Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate__allTimerRelease12Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate__allActionRelease12Expression(an1 : Action, an2 : Action, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate__allActionRelease1'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_releases']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_releases']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate__allActionRelease12Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Action, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate__allActionRelease1'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_releases']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::_allActionRelease12Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Action) := allActions->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate__allActionRelease12Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate__allActionRelease12Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate__allActionRelease12Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	mapping inMM2::Model::_allTimerAndConnectionRelease22Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union__allTimerAndConnectionRelease2';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map _allTimerRelease22Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map _allConnectionRelease22Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate__allConnectionRelease22Expression(an1 : Connection, an2 : Connection, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate__allConnectionRelease2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_releases']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_releases']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate__allConnectionRelease22Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Connection, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate__allConnectionRelease2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_releases']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::_allConnectionRelease22Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Connection) := allTimedConnections->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate__allConnectionRelease22Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate__allConnectionRelease22Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate__allConnectionRelease22Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate__allTimerRelease22Expression(an1 : Timer, an2 : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate__allTimerRelease2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_releases']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_releases']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate__allTimerRelease22Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate__allTimerRelease2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_releases']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::_allTimerRelease22Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Timer) := allTimers->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate__allTimerRelease22Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate__allTimerRelease22Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate__allTimerRelease22Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	mapping inMM2::Model::allAandTWait2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_allAandTWait';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allTimersWait2Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allActionsWait2Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate_allActionsWait2Expression(an1 : Action, an2 : Action, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allActionsWait'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_wait']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_wait']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate_allActionsWait2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Action, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allActionsWait'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_wait']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::allActionsWait2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Action) := allActions->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allActionsWait2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allActionsWait2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allActionsWait2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate_allTimersWait2Expression(an1 : Timer, an2 : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allTimersWait'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_wait']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_wait']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate_allTimersWait2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allTimersWait'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_wait']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::allTimersWait2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Timer) := allTimers->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allTimersWait2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allTimersWait2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allTimersWait2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	mapping inMM2::Model::_allTimerAndConnectionRelease2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union__allTimerAndConnectionRelease';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allTimersWait22Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map _allConnectionWait22Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate__allConnectionWait22Expression(an1 : Connection, an2 : Connection, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate__allConnectionWait2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_wait']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_wait']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate__allConnectionWait22Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Connection, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate__allConnectionWait2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_wait']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::_allConnectionWait22Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Connection) := allTimedConnections->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate__allConnectionWait22Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate__allConnectionWait22Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate__allConnectionWait22Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Model::intermediate_allTimersWait22Expression(an1 : Timer, an2 : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allTimersWait2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_wait']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_wait']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Model::intermediate_allTimersWait22Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allTimersWait2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_wait']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Model::allTimersWait22Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		//from lets
		

		var sources : Sequence(Timer) := allTimers->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allTimersWait22Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allTimersWait22Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allTimersWait22Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Instantiation::intermediate_allTimers2Expression(an1 : Timer, an2 : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allTimers'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
				var type : Reactor := theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first();
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_starts']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_starts']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Instantiation::intermediate_allTimers2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allTimers'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
				var type : Reactor := theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first();
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_starts']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Instantiation::allTimers2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
				var type : Reactor := theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first();
		
		//from lets
		

		var sources : Sequence(Timer) := type.timers->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allTimers2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allTimers2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allTimers2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Instantiation::intermediate_allInputUpdates2Expression(an1 : Input, an2 : Input, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allInputUpdates'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Sup")->first();
		//from defs
				var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
				var type : Reactor := theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first();
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_updates']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_updates']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Instantiation::intermediate_allInputUpdates2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Input, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allInputUpdates'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Sup")->first();
		//from defs
				var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
				var type : Reactor := theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first();
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_updates']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Instantiation::allInputUpdates2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
				var type : Reactor := theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first();
		
		//from lets
		

		var sources : Sequence(Input) := type.inputs->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allInputUpdates2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allInputUpdates2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allInputUpdates2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	mapping inMM2::Instantiation::allTriggers2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_allTriggers';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
				var type : Reactor := theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first();
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allTimers22Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allInputUpdates22Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Instantiation::intermediate_allInputUpdates22Expression(an1 : Input, an2 : Input, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allInputUpdates2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
				var type : Reactor := theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first();
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_updates']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_updates']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Instantiation::intermediate_allInputUpdates22Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Input, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allInputUpdates2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
				var type : Reactor := theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first();
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_updates']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Instantiation::allInputUpdates22Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
				var type : Reactor := theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first();
		
		//from lets
		

		var sources : Sequence(Input) := type.inputs->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allInputUpdates22Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allInputUpdates22Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allInputUpdates22Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Instantiation::intermediate_allTimers22Expression(an1 : Timer, an2 : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allTimers2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
				var type : Reactor := theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first();
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_updates']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_updates']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Instantiation::intermediate_allTimers22Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Timer, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allTimers2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		//from defs
				var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
				var type : Reactor := theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first();
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_updates']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Instantiation::allTimers22Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
				var type : Reactor := theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first();
		
		//from lets
		

		var sources : Sequence(Timer) := type.timers->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allTimers22Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allTimers22Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allTimers22Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Instantiation::intermediate_firstReactionExec2Expression(an1 : Reaction, an2 : Reaction, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_firstReactionExec'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Inf")->first();
		//from defs
				var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
				var type : Reactor := theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first();
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_synchronousExecution']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Inf']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Inf).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_synchronousExecution']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Inf']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Inf).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Instantiation::intermediate_firstReactionExec2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Reaction, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_firstReactionExec'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Inf")->first();
		//from defs
				var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
				var type : Reactor := theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first();
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Inf']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Inf).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_synchronousExecution']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Inf']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Inf).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Instantiation::firstReactionExec2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
				var type : Reactor := theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first();
		
		//from lets
		

		var sources : Sequence(Reaction) := type.reactions->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_firstReactionExec2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_firstReactionExec2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_firstReactionExec2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Instantiation::intermediate_lastReactionExec2Expression(an1 : Reaction, an2 : Reaction, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_lastReactionExec'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Sup")->first();
		//from defs
				var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
				var type : Reactor := theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first();
		
		//from lets
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_synchronousExecution']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_synchronousExecution']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Instantiation::intermediate_lastReactionExec2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Reaction, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_lastReactionExec'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Sup")->first();
		//from defs
				var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
				var type : Reactor := theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first();
		
		//from lets
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_synchronousExecution']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Instantiation::lastReactionExec2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
				var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
				var type : Reactor := theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first();
		
		//from lets
		

		var sources : Sequence(Reaction) := type.reactions->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_lastReactionExec2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_lastReactionExec2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_lastReactionExec2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM2::Reaction::intermediate_lastInput2Expression(an1 : Variable, an2 : Variable, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_lastInput'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Sup")->first();
		//from defs
		
		//from lets
				var allInputsNoTimer : Sequence(Variable) := self.triggers.oclAsType(VarRef).variable->select(t|t.oclIsKindOf(Variable) and (not t.oclIsKindOf(Timer)) and (not t.oclIsKindOf(Action)));
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_updates']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_updates']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM2::Reaction::intermediate_lastInput2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Variable, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_lastInput'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Sup")->first();
		//from defs
		
		//from lets
				var allInputsNoTimer : Sequence(Variable) := self.triggers.oclAsType(VarRef).variable->select(t|t.oclIsKindOf(Variable) and (not t.oclIsKindOf(Timer)) and (not t.oclIsKindOf(Action)));
		
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_updates']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Sup']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Sup).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM2::Reaction::lastInput2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
		
		//from lets
				var allInputsNoTimer : Sequence(Variable) := self.triggers.oclAsType(VarRef).variable->select(t|t.oclIsKindOf(Variable) and (not t.oclIsKindOf(Timer)) and (not t.oclIsKindOf(Action)));
		

		var sources : Sequence(Variable) := allInputsNoTimer->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_lastInput2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_lastInput2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_lastInput2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}





//relation stuff		
	 	mapping inMM2::Model::timeJump2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_timeJump';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "timeJump")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_timeJump';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM2::Model::untimedAction2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_untimedAction';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_untimedAction';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM2::Model::allTimerAndActionRelease2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_allTimerAndActionRelease';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_allTimerAndActionRelease';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM2::Model::allCanRelease2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_allCanRelease';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_allCanRelease';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM2::Model::allWait2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_allWait';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_allWait';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM2::Instantiation::startExecuting2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_startExecuting';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_startExecuting';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM2::Instantiation::finishExecuting2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_finishExecuting';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_finishExecuting';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM2::Reactor::startExecuting2Clock() :TimeModel::Clock 
			when { (self._main) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_startExecuting';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_startExecuting';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM2::Reactor::finishExecuting2Clock() :TimeModel::Clock 
			when { (self._main) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_finishExecuting';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_finishExecuting';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM2::Reaction::synchronousExecution2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_synchronousExecution';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_synchronousExecution';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM2::Variable::updates2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_updates';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_updates';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM2::Timer::starts2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_starts';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "schedule")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_starts';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM2::Timer::releases2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_releases';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "release")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_releases';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM2::Timer::wait2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_wait';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_wait';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM2::Timer::canRelease2Clock() :TimeModel::Clock 
			when { (true) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_canRelease';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "canTick")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_canRelease';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM2::Action::starts2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_starts';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "schedule")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_starts';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM2::Action::releases2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_releases';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "release")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_releases';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM2::Action::wait2Clock() :TimeModel::Clock 
			when { (self.minDelay <> null and self.minDelay.time <> null) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_wait';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_wait';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM2::Action::canRelease2Clock() :TimeModel::Clock 
			when { (self.minDelay <> null and self.minDelay.time <> null) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_canRelease';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "canTick")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_canRelease';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM2::Connection::starts2Clock() :TimeModel::Clock 
			when { (self.delay <> null and self.delay.time <> null) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_starts';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "schedule")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_starts';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM2::Connection::releases2Clock() :TimeModel::Clock 
			when { (self.delay <> null and self.delay.time <> null) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_releases';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "release")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_releases';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM2::Connection::wait2Clock() :TimeModel::Clock 
			when { (self.delay <> null and self.delay.time <> null) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_wait';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_wait';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM2::Connection::canRelease2Clock() :TimeModel::Clock 
			when { (self.delay <> null and self.delay.time <> null) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_canRelease';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "canTick")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_canRelease';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		

//relation stuff		
		
	
		mapping inMM2::Model::eitherTimedOrUntimed12eitherTimedOrUntimed(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Exclusion_eitherTimedOrUntimed";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_timeJump']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_untimedAction']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
		
	
		mapping inMM2::Model::untimedPriorTimed2Exclusion12untimedPriorTimed2Exclusion(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Exclusion_untimedPriorTimed2Exclusion";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_untimedAction']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_allTimerAndActionRelease']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
		
	
		mapping inMM2::Model::untimedPriorTimed3Exclusion12untimedPriorTimed3Exclusion(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Exclusion_untimedPriorTimed3Exclusion";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_untimedAction']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_allCanRelease']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM2::Reaction::propagatesPrio112propagatesPrio1(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"SubClock_propagatesPrio1";
			type := seqOfRelationDeclaration->select(rd | rd.name = "SubClock")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_synchronousExecution']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(theModel.oclAsType(EObject))+'_untimedAction']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM2::Port::propagatesPrio212propagatesPrio2(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"SubClock_propagatesPrio2";
			type := seqOfRelationDeclaration->select(rd | rd.name = "SubClock")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_updates']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(theModel.oclAsType(EObject))+'_untimedAction']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM2::Instantiation::propagatesPrio312propagatesPrio3(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"SubClock_propagatesPrio3";
			type := seqOfRelationDeclaration->select(rd | rd.name = "SubClock")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_startExecuting']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(theModel.oclAsType(EObject))+'_untimedAction']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Instantiation::propagatesPrio412propagatesPrio4(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"SubClock_propagatesPrio4";
			type := seqOfRelationDeclaration->select(rd | rd.name = "SubClock")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_finishExecuting']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(theModel.oclAsType(EObject))+'_untimedAction']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM2::Timer::propagatesPrio512propagatesPrio5(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"SubClock_propagatesPrio5";
			type := seqOfRelationDeclaration->select(rd | rd.name = "SubClock")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_starts']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(theModel.oclAsType(EObject))+'_untimedAction']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Timer::propagatesPrio712propagatesPrio7(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"SubClock_propagatesPrio7";
			type := seqOfRelationDeclaration->select(rd | rd.name = "SubClock")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_canRelease']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(theModel.oclAsType(EObject))+'_allCanRelease']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Timer::propagatesPrio912propagatesPrio9(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"SubClock_propagatesPrio9";
			type := seqOfRelationDeclaration->select(rd | rd.name = "SubClock")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_wait']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(theModel.oclAsType(EObject))+'_allWait']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM2::Action::propagatesPrio612propagatesPrio6(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"SubClock_propagatesPrio6";
			type := seqOfRelationDeclaration->select(rd | rd.name = "SubClock")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_starts']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(theModel.oclAsType(EObject))+'_untimedAction']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Action::propagatesPrio822propagatesPrio8(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let theModel : Model = self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model) in
				
				(self.minDelay <> null and self.minDelay.time <> null) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"SubClock_propagatesPrio8";
			type := seqOfRelationDeclaration->select(rd | rd.name = "SubClock")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_canRelease']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(theModel.oclAsType(EObject))+'_allCanRelease']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Action::propagatesPrio1022propagatesPrio10(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let theModel : Model = self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model) in
				
				(self.minDelay <> null and self.minDelay.time <> null) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"SubClock_propagatesPrio10";
			type := seqOfRelationDeclaration->select(rd | rd.name = "SubClock")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_wait']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(theModel.oclAsType(EObject))+'_allWait']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM2::Connection::propagatesPrio1122propagatesPrio11(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let theModel : Model = self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model) in
				
				(self.delay <> null and self.delay.time <> null) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"SubClock_propagatesPrio11";
			type := seqOfRelationDeclaration->select(rd | rd.name = "SubClock")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_starts']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(theModel.oclAsType(EObject))+'_untimedAction']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Connection::propagatesPrio1222propagatesPrio12(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let theModel : Model = self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model) in
				
				(self.delay <> null and self.delay.time <> null) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"SubClock_propagatesPrio12";
			type := seqOfRelationDeclaration->select(rd | rd.name = "SubClock")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_canRelease']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(theModel.oclAsType(EObject))+'_allCanRelease']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Connection::propagatesPrio1322propagatesPrio13(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let theModel : Model = self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model) in
				
				(self.delay <> null and self.delay.time <> null) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"SubClock_propagatesPrio13";
			type := seqOfRelationDeclaration->select(rd | rd.name = "SubClock")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_wait']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(theModel.oclAsType(EObject))+'_allWait']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	

//Create an intermediate relation
	mapping inMM2::Model::intermediate_onlyOneCanTickAtATime112onlyOneCanTickAtATime1(an1 : Timer, an2 : Timer, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_onlyOneCanTickAtATime1'+nbi.toString()+"_"+nbj.toString();
		var seqAbstract : Sequence(Stdlib::Element) := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Exclusion).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence();
		type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		

					bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_canRelease']->first();
						_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;

				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_canRelease']->first();
						_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;

				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM2::Model::onlyOneCanTickAtATime112onlyOneCanTickAtATime1()
	{
		init{
					var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
					var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
					var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
			
			
			var sources : Sequence(Timer) := allTimers->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_onlyOneCanTickAtATime112onlyOneCanTickAtATime1(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		
	

//Create an intermediate relation
	mapping inMM2::Model::intermediate_onlyOneCanTickAtATime212onlyOneCanTickAtATime2(an1 : Action, an2 : Action, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_onlyOneCanTickAtATime2'+nbi.toString()+"_"+nbj.toString();
		var seqAbstract : Sequence(Stdlib::Element) := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Exclusion).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence();
		type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		

					bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_canRelease']->first();
						_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;

				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_canRelease']->first();
						_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;

				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM2::Model::onlyOneCanTickAtATime212onlyOneCanTickAtATime2()
	{
		init{
					var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
					var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
					var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
			
			
			var sources : Sequence(Action) := allActions->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_onlyOneCanTickAtATime212onlyOneCanTickAtATime2(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		
	
		mapping inMM2::Model::onlyOneCanTickAtATime342onlyOneCanTickAtATime3(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let allTimers : Collection(Timer) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer) in
						let allActions : Collection(Action) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action) in
						let allTimedConnections : Collection(Connection) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection) in
				
				(allActions->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Exclusion_onlyOneCanTickAtATime3";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
					var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
					var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
					var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allTimerCanTick2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allActionCanTick2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	

//Create an intermediate relation
	mapping inMM2::Model::intermediate_onlyOneReleaseAtATime112onlyOneReleaseAtATime1(an1 : Timer, an2 : Timer, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_onlyOneReleaseAtATime1'+nbi.toString()+"_"+nbj.toString();
		var seqAbstract : Sequence(Stdlib::Element) := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Exclusion).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence();
		type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		

					bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_releases']->first();
						_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;

				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_releases']->first();
						_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;

				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM2::Model::onlyOneReleaseAtATime112onlyOneReleaseAtATime1()
	{
		init{
					var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
					var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
					var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
			
			
			var sources : Sequence(Timer) := allTimers->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_onlyOneReleaseAtATime112onlyOneReleaseAtATime1(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		
	

//Create an intermediate relation
	mapping inMM2::Model::intermediate_onlyOneReleaseAtATime222onlyOneReleaseAtATime2(an1 : Action, an2 : Action, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_onlyOneReleaseAtATime2'+nbi.toString()+"_"+nbj.toString();
		var seqAbstract : Sequence(Stdlib::Element) := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Exclusion).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence();
		type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		

					bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_releases']->first();
						_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;

				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_releases']->first();
						_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;

				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM2::Model::onlyOneReleaseAtATime222onlyOneReleaseAtATime2()
			when { 
						let allTimers : Collection(Timer) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer) in
						let allActions : Collection(Action) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action) in
						let allTimedConnections : Collection(Connection) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection) in
				
				(allActions->size() > 0) 
			}
	{
		init{
					var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
					var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
					var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
			
			
			var sources : Sequence(Action) := allActions->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_onlyOneReleaseAtATime222onlyOneReleaseAtATime2(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		
	
		mapping inMM2::Model::onlyOneReleaseAtATime342onlyOneReleaseAtATime3(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let allTimers : Collection(Timer) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer) in
						let allActions : Collection(Action) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action) in
						let allTimedConnections : Collection(Connection) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection) in
				
				(allActions->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Exclusion_onlyOneReleaseAtATime3";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
					var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
					var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
					var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allTimerRelease2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allActionRelease2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	

//Create an intermediate relation
	mapping inMM2::Model::intermediate_onlyOneWaitAtATime112onlyOneWaitAtATime1(an1 : Timer, an2 : Timer, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_onlyOneWaitAtATime1'+nbi.toString()+"_"+nbj.toString();
		var seqAbstract : Sequence(Stdlib::Element) := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Exclusion).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence();
		type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		

					bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_wait']->first();
						_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;

				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_wait']->first();
						_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;

				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM2::Model::onlyOneWaitAtATime112onlyOneWaitAtATime1()
	{
		init{
					var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
					var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
					var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
			
			
			var sources : Sequence(Timer) := allTimers->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_onlyOneWaitAtATime112onlyOneWaitAtATime1(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		
	

//Create an intermediate relation
	mapping inMM2::Model::intermediate_onlyOneWaitAtATime212onlyOneWaitAtATime2(an1 : Action, an2 : Action, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_onlyOneWaitAtATime2'+nbi.toString()+"_"+nbj.toString();
		var seqAbstract : Sequence(Stdlib::Element) := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Exclusion).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence();
		type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
				var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
				var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
				var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
		
		

					bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_wait']->first();
						_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;

				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_wait']->first();
						_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;

				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM2::Model::onlyOneWaitAtATime212onlyOneWaitAtATime2()
	{
		init{
					var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
					var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
					var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
			
			
			var sources : Sequence(Action) := allActions->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_onlyOneWaitAtATime212onlyOneWaitAtATime2(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		
	
		mapping inMM2::Model::onlyOneWaitAtATime342onlyOneWaitAtATime3(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let allTimers : Collection(Timer) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer) in
						let allActions : Collection(Action) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action) in
						let allTimedConnections : Collection(Connection) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection) in
				
				(allActions->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Exclusion_onlyOneWaitAtATime3";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
					var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
					var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
					var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allTimerWait2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allActionWait2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
		
	
		mapping inMM2::Model::canReleasePriorReleaseExclusion12canReleasePriorReleaseExclusion(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Exclusion_canReleasePriorReleaseExclusion";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
					var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
					var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
					var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_allCanRelease']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_allTimerAndActionRelease']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
		
	
		mapping inMM2::Model::canReleasePriorWaitExclusion12canReleasePriorWaitExclusion(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Exclusion_canReleasePriorWaitExclusion";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
					var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
					var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
					var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_allCanRelease']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_allWait']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Model::defUntimedAction132defUntimedAction(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let allTimers : Collection(Timer) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer) in
						let allActions : Collection(Action) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action) in
						let allTimedConnections : Collection(Connection) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection) in
				
				(allActions->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_defUntimedAction";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
					var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
					var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_untimedAction']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map union1_2_3_4_52Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Model::defUntimedActionNoAction132defUntimedActionNoAction(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let allTimers : Collection(Timer) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer) in
						let allActions : Collection(Action) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action) in
						let allTimedConnections : Collection(Connection) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection) in
				
				(allActions->size()=  0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_defUntimedActionNoAction";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
					var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
					var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_untimedAction']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map union21_2_3_4_52Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Model::defAllCanRelease52defAllCanRelease(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let allTimers : Collection(Timer) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer) in
						let allActions : Collection(Action) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action) in
						let allTimedConnections : Collection(Connection) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection) in
				
				(allActions->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_defAllCanRelease";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
					var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
					var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map _allTimerAndActionCanRelease12Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_allCanRelease']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Model::defAllCanReleaseNoAction52defAllCanReleaseNoAction(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let allTimers : Collection(Timer) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer) in
						let allActions : Collection(Action) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action) in
						let allTimedConnections : Collection(Connection) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection) in
				
				(allActions->size() = 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_defAllCanReleaseNoAction";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
					var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
					var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map _allTimerAndConnectionCanRelease22Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_allCanRelease']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Model::defAllTimerAndActionRelease52defAllTimerAndActionRelease(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let allTimers : Collection(Timer) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer) in
						let allActions : Collection(Action) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action) in
						let allTimedConnections : Collection(Connection) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection) in
				
				(allActions->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_defAllTimerAndActionRelease";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
					var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
					var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map _allTimerAndActionRelease12Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_allTimerAndActionRelease']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Model::defAllTimerAndActionReleaseNoAction52defAllTimerAndActionReleaseNoAction(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let allTimers : Collection(Timer) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer) in
						let allActions : Collection(Action) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action) in
						let allTimedConnections : Collection(Connection) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection) in
				
				(allActions->size() = 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_defAllTimerAndActionReleaseNoAction";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
					var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
					var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_allTimerAndActionRelease']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map _allTimerAndConnectionRelease22Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Model::defAllWait52defAllWait(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let allTimers : Collection(Timer) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer) in
						let allActions : Collection(Action) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action) in
						let allTimedConnections : Collection(Connection) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection) in
				
				(allActions->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_defAllWait";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
					var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
					var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_allWait']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allAandTWait2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Model::defAllWaitNoAction52defAllWaitNoAction(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let allTimers : Collection(Timer) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer) in
						let allActions : Collection(Action) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action) in
						let allTimedConnections : Collection(Connection) = self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection) in
				
				(allActions->size() = 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_defAllWaitNoAction";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var allTimers : Collection(Timer) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Timer)).oclAsType(Timer);
					var allActions : Collection(Action) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Action)).oclAsType(Action);
					var allTimedConnections : Collection(Connection) := self.oclAsType(ecore::EObject).allSubobjects()->select(eo | eo.oclIsKindOf(Connection) and eo.oclAsType(Connection).delay <> null and eo.oclAsType(Connection).delay.time <> null).oclAsType(Connection);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_allWait']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map _allTimerAndConnectionRelease2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM2::Timer::timerStartsWhenUpdates12timerStartsWhenUpdates(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_timerStartsWhenUpdates";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_updates']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_starts']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Timer::timerWaitOrRelease12timerWaitOrRelease(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Exclusion_timerWaitOrRelease";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_wait']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_releases']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Timer::timerSetActionLifeCycle22timerSetActionLifeCycle(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"TimerConstraint_timerSetActionLifeCycle";
			type := seqOfRelationDeclaration->select(rd | rd.name = "TimerConstraint")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
					var nbInputs : Integer := 1;
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_starts']->first();
					_abstract := seqOfAbstractEntity[name = 'TimerConstraint_starts']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_canRelease']->first();
					_abstract := seqOfAbstractEntity[name = 'TimerConstraint_canTick']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_wait']->first();
					_abstract := seqOfAbstractEntity[name = 'TimerConstraint_wait']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_releases']->first();
					_abstract := seqOfAbstractEntity[name = 'TimerConstraint_release']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(theModel.oclAsType(EObject))+'_timeJump']->first();
					_abstract := seqOfAbstractEntity[name = 'TimerConstraint_timeJump']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := 1 -> map Real2Integer(getNameOrUID(self.oclAsType(EObject))+getNameOrUID(self.oclAsType(EObject))+"_1")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'TimerConstraint_nbStarts']->first();
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM2::Action::actionStartsWhenUpdates12actionStartsWhenUpdates(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_actionStartsWhenUpdates";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_updates']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_starts']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Action::actionWaitOrRelease22actionWaitOrRelease(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let theModel : Model = self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model) in
				
				(self.minDelay <> null and self.minDelay.time <> null) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Exclusion_actionWaitOrRelease";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_wait']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_releases']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Action::ActionSourceCoincidesTarget42ActionSourceCoincidesTarget(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let theModel : Model = self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model) in
				
				(self.minDelay = null or self.minDelay.time = null) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"AlternatesFSM_ActionSourceCoincidesTarget";
			type := seqOfRelationDeclaration->select(rd | rd.name = "AlternatesFSM")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
					var source : Reaction := self.oclAsType(ecore::EObject).eContainer().oclAsType(Reactor).reactions
							->select(r | r.effects->first().variable.name = self.name)->first();
					var target : Reaction := self.oclAsType(ecore::EObject).eContainer().oclAsType(Reactor).reactions
							->select(r | r.triggers->first().oclIsKindOf(VarRef) and r.triggers.oclAsType(VarRef)->first().variable.name = self.name)->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(source.oclAsType(EObject))+'_synchronousExecution']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesFSM_left']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(target.oclAsType(EObject))+'_synchronousExecution']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesFSM_right']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Action::ActionSourceBeforeTarget42ActionSourceBeforeTarget(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let theModel : Model = self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model) in
				
				(self.minDelay <> null and self.minDelay.time <> null) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"AlternatesFSM_ActionSourceBeforeTarget";
			type := seqOfRelationDeclaration->select(rd | rd.name = "AlternatesFSM")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
					var source : Reaction := self.oclAsType(ecore::EObject).eContainer().oclAsType(Reactor).reactions
							->select(r | r.effects->first().variable.name = self.name)->first();
					var target : Reaction := self.oclAsType(ecore::EObject).eContainer().oclAsType(Reactor).reactions
							->select(r | r.triggers->first().oclIsKindOf(VarRef) and r.triggers.oclAsType(VarRef)->first().variable.name = self.name)->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(source.oclAsType(EObject))+'_synchronousExecution']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesFSM_left']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(target.oclAsType(EObject))+'_synchronousExecution']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesFSM_right']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Action::ActionTargetWhenReleased32ActionTargetWhenReleased(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let theModel : Model = self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model) in
				
				(self.minDelay <> null and self.minDelay.time <> null) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"AlternatesFSM_ActionTargetWhenReleased";
			type := seqOfRelationDeclaration->select(rd | rd.name = "AlternatesFSM")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
					var target : Reaction := self.oclAsType(ecore::EObject).eContainer().oclAsType(Reactor).reactions
							->select(r | r.triggers->first().oclIsKindOf(VarRef) and r.triggers.oclAsType(VarRef)->first().variable.name = self.name)->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_releases']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesFSM_left']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(target.oclAsType(EObject))+'_synchronousExecution']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesFSM_right']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Action::setActionLifeCycle42setActionLifeCycle(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let theModel : Model = self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model) in
				
							let theReactor : Reactor = self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Reactor))->asSequence()->first().oclAsType(Reactor) in
							let nbInputs : Integer = theReactor.inputs->size() in
					
				(self.minDelay <> null and self.minDelay.time <> null) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"TimerConstraint_setActionLifeCycle";
			type := seqOfRelationDeclaration->select(rd | rd.name = "TimerConstraint")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
					var theReactor : Reactor := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Reactor))->asSequence()->first().oclAsType(Reactor);
					var nbInputs : Integer := theReactor.inputs->size();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_starts']->first();
					_abstract := seqOfAbstractEntity[name = 'TimerConstraint_starts']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_canRelease']->first();
					_abstract := seqOfAbstractEntity[name = 'TimerConstraint_canTick']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_wait']->first();
					_abstract := seqOfAbstractEntity[name = 'TimerConstraint_wait']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_releases']->first();
					_abstract := seqOfAbstractEntity[name = 'TimerConstraint_release']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(theModel.oclAsType(EObject))+'_timeJump']->first();
					_abstract := seqOfAbstractEntity[name = 'TimerConstraint_timeJump']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := theReactor.inputs->size() -> map Real2Integer(getNameOrUID(self.oclAsType(EObject))+invalid.toString()+"_size()")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'TimerConstraint_nbStarts']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Action::setNullLifeCycle22setNullLifeCycle(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let theModel : Model = self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model) in
				
				(self.minDelay = null or self.minDelay.time = null) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"AlternatesFSM_setNullLifeCycle";
			type := seqOfRelationDeclaration->select(rd | rd.name = "AlternatesFSM")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_starts']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesFSM_left']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_releases']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesFSM_right']->first();
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	

//Create an intermediate relation
	mapping inMM2::Reactor::intermediate_mainReactorStartNoInputInstanceWhenStartsPart122mainReactorStartNoInputInstanceWhenStartsPart1(an1 : Instantiation, an2 : Instantiation, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_mainReactorStartNoInputInstanceWhenStartsPart1'+nbi.toString()+"_"+nbj.toString();
		var seqAbstract : Sequence(Stdlib::Element) := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Coincidence).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence();
		type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
				var instancesWithNoInput : Collection(Instantiation) := self.instantiations->select(
								i | theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = i.reactorClass.name)->asSequence()->first().oclAsType(Reactor).inputs->size() = 0
								).oclAsType(Instantiation);
		
		

					bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_startExecuting']->first();
						_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;

				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_startExecuting']->first();
						_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;

				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM2::Reactor::mainReactorStartNoInputInstanceWhenStartsPart122mainReactorStartNoInputInstanceWhenStartsPart1()
			when { 
						let theModel : Model = self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model) in
						let instancesWithNoInput : Collection(Instantiation) = self.instantiations->select(
										i | theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = i.reactorClass.name)->asSequence()->first().oclAsType(Reactor).inputs->size() = 0
										).oclAsType(Instantiation) in
				
				(self._main and instancesWithNoInput->size() > 1) 
			}
	{
		init{
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
					var instancesWithNoInput : Collection(Instantiation) := self.instantiations->select(
									i | theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = i.reactorClass.name)->asSequence()->first().oclAsType(Reactor).inputs->size() = 0
									).oclAsType(Instantiation);
			
			
			var sources : Sequence(Instantiation) := instancesWithNoInput->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_mainReactorStartNoInputInstanceWhenStartsPart122mainReactorStartNoInputInstanceWhenStartsPart1(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		
	
		mapping inMM2::Reactor::mainReactorStartNoInputInstanceWhenStartsPart222mainReactorStartNoInputInstanceWhenStartsPart2(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let theModel : Model = self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model) in
						let instancesWithNoInput : Collection(Instantiation) = self.instantiations->select(
										i | theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = i.reactorClass.name)->asSequence()->first().oclAsType(Reactor).inputs->size() = 0
										).oclAsType(Instantiation) in
				
				(self._main) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_mainReactorStartNoInputInstanceWhenStartsPart2";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
					var instancesWithNoInput : Collection(Instantiation) := self.instantiations->select(
									i | theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = i.reactorClass.name)->asSequence()->first().oclAsType(Reactor).inputs->size() = 0
									).oclAsType(Instantiation);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(instancesWithNoInput->asSequence()->first().oclAsType(EObject))+'_startExecuting']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_startExecuting']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Reactor::mainReactorNeverFinish22mainReactorNeverFinish(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let theModel : Model = self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model) in
						let instancesWithNoInput : Collection(Instantiation) = self.instantiations->select(
										i | theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = i.reactorClass.name)->asSequence()->first().oclAsType(Reactor).inputs->size() = 0
										).oclAsType(Instantiation) in
				
				(self._main) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"NeverTick_mainReactorNeverFinish";
			type := seqOfRelationDeclaration->select(rd | rd.name = "NeverTick")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
					var instancesWithNoInput : Collection(Instantiation) := self.instantiations->select(
									i | theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = i.reactorClass.name)->asSequence()->first().oclAsType(Reactor).inputs->size() = 0
									).oclAsType(Instantiation);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_finishExecuting']->first();
					_abstract := seqOfAbstractEntity[name = 'nevertCickingClock']->first();
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM2::Instantiation::startComputeTimerOnly32startComputeTimerOnly(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let theModel : Model = self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model) in
						let type : Reactor = theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first() in
				
				(    (type.timers->size() > 0)
		 and (type.inputs->size() = 0)	
		) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_startComputeTimerOnly";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
					var type : Reactor := theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first();
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_startExecuting']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allTimers2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Instantiation::startComputeInputOnly32startComputeInputOnly(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let theModel : Model = self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model) in
						let type : Reactor = theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first() in
				
				(    (type.timers->size() = 0)
		 and (type.inputs->size() > 0)
		) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"AlternatesFSM_startComputeInputOnly";
			type := seqOfRelationDeclaration->select(rd | rd.name = "AlternatesFSM")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
					var type : Reactor := theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first();
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allInputUpdates2Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesFSM_left']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_startExecuting']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesFSM_right']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Instantiation::startComputeInputAndTimer52startComputeInputAndTimer(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let theModel : Model = self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model) in
						let type : Reactor = theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first() in
				
				(    (type.timers->size() > 0)
		 and (type.inputs->size() > 0)
		) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"AlternatesFSM_startComputeInputAndTimer";
			type := seqOfRelationDeclaration->select(rd | rd.name = "AlternatesFSM")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
					var type : Reactor := theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first();
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allTriggers2Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesFSM_left']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_startExecuting']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesFSM_right']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Instantiation::startInternalReactionWhenStart32startInternalReactionWhenStart(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let theModel : Model = self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model) in
						let type : Reactor = theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first() in
				
				(type.reactions->size() > 0 and type.timers->size() = 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"AlternatesFSM_startInternalReactionWhenStart";
			type := seqOfRelationDeclaration->select(rd | rd.name = "AlternatesFSM")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
					var type : Reactor := theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first();
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_startExecuting']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesFSM_left']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map firstReactionExec2Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesFSM_right']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Instantiation::FinishInternalReactionWhenFinish32FinishInternalReactionWhenFinish(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let theModel : Model = self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model) in
						let type : Reactor = theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first() in
				
				(type.reactions->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_FinishInternalReactionWhenFinish";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
					var type : Reactor := theModel.oclAsType(ecore::EObject).allSubobjects()->select(r | r.oclIsKindOf(Reactor) and r.oclAsType(Reactor).name = self.reactorClass.name).oclAsType(Reactor)->asSequence()->first();
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map lastReactionExec2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_finishExecuting']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM2::Connection::ConnectorSourceBeforeTarget22ConnectorSourceBeforeTarget(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let theModel : Model = self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model) in
				
				(self.delay = null or self.delay.time = null) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_ConnectorSourceBeforeTarget";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.leftPorts.variable->first().oclAsType(EObject))+'_updates']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.rightPorts.variable->first().oclAsType(EObject))+'_updates']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Connection::ConnectorSourceBeforeTargetTimed32ConnectorSourceBeforeTargetTimed(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let theModel : Model = self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model) in
				
				(self.delay <> null and self.delay.time <> null) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"TimerConstraint_ConnectorSourceBeforeTargetTimed";
			type := seqOfRelationDeclaration->select(rd | rd.name = "TimerConstraint")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
					var nbInputs : Integer := 1;
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_starts']->first();
					_abstract := seqOfAbstractEntity[name = 'TimerConstraint_starts']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_canRelease']->first();
					_abstract := seqOfAbstractEntity[name = 'TimerConstraint_canTick']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_wait']->first();
					_abstract := seqOfAbstractEntity[name = 'TimerConstraint_wait']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_releases']->first();
					_abstract := seqOfAbstractEntity[name = 'TimerConstraint_release']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(theModel.oclAsType(EObject))+'_timeJump']->first();
					_abstract := seqOfAbstractEntity[name = 'TimerConstraint_timeJump']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := 1 -> map Real2Integer(getNameOrUID(self.oclAsType(EObject))+getNameOrUID(self.oclAsType(EObject))+"_1")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'TimerConstraint_nbStarts']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Connection::TimedConnectorStartsWithSource22TimedConnectorStartsWithSource(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let theModel : Model = self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model) in
				
				(self.delay <> null and self.delay.time <> null) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_TimedConnectorStartsWithSource";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_starts']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.leftPorts.variable->first().oclAsType(EObject))+'_updates']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Connection::TimedConnectorReleaseWithTarget22TimedConnectorReleaseWithTarget(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
						let theModel : Model = self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model) in
				
				(self.delay <> null and self.delay.time <> null) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Precedes_TimedConnectorReleaseWithTarget";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
					var theModel : Model := self.oclAsType(ecore::EObject)->closure(s | s.oclAsType(ecore::EObject).eContainer())->select(eo | eo.oclIsKindOf(Model))->asSequence()->first().oclAsType(Model);
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_releases']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.rightPorts.variable->first().oclAsType(EObject))+'_updates']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM2::Reaction::startWhenTheOnlyInputArrivedNoTimer32startWhenTheOnlyInputArrivedNoTimer(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				
							let allInputsNoTimer : Sequence(Variable) = self.triggers.oclAsType(VarRef).variable->select(t|t.oclIsKindOf(Variable) and (not t.oclIsKindOf(Timer)) and (not t.oclIsKindOf(Action))) in
					
				(allInputsNoTimer->size() = 1) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"AlternatesFSM_startWhenTheOnlyInputArrivedNoTimer";
			type := seqOfRelationDeclaration->select(rd | rd.name = "AlternatesFSM")->first();
			
					var allInputsNoTimer : Sequence(Variable) := self.triggers.oclAsType(VarRef).variable->select(t|t.oclIsKindOf(Variable) and (not t.oclIsKindOf(Timer)) and (not t.oclIsKindOf(Action)));
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(allInputsNoTimer->first().oclAsType(EObject))+'_updates']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesFSM_left']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_synchronousExecution']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesFSM_right']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Reaction::startWhenTheLastInputArrivedNoTimer42startWhenTheLastInputArrivedNoTimer(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				
							let allInputsNoTimer : Sequence(Variable) = self.triggers.oclAsType(VarRef).variable->select(t|t.oclIsKindOf(Variable) and (not t.oclIsKindOf(Timer)) and (not t.oclIsKindOf(Action))) in
					
				(allInputsNoTimer->size() > 1) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"AlternatesFSM_startWhenTheLastInputArrivedNoTimer";
			type := seqOfRelationDeclaration->select(rd | rd.name = "AlternatesFSM")->first();
			
					var allInputsNoTimer : Sequence(Variable) := self.triggers.oclAsType(VarRef).variable->select(t|t.oclIsKindOf(Variable) and (not t.oclIsKindOf(Timer)) and (not t.oclIsKindOf(Action)));
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map lastInput2Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesFSM_left']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_synchronousExecution']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesFSM_right']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Reaction::startWhenTheTimerRelease22startWhenTheTimerRelease(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				
				(self.triggers.oclAsType(VarRef).variable->select(t| t.oclIsKindOf(Timer))->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"AlternatesFSM_startWhenTheTimerRelease";
			type := seqOfRelationDeclaration->select(rd | rd.name = "AlternatesFSM")->first();
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.triggers.oclAsType(VarRef).variable->select(t| t.oclIsKindOf(Timer))->first().oclAsType(Timer).oclAsType(EObject))+'_releases']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesFSM_left']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_synchronousExecution']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesFSM_right']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM2::Reaction::startWhenTheActionRelease22startWhenTheActionRelease(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				
				(self.triggers.oclAsType(VarRef).variable->select(t| t.oclIsKindOf(Action))->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"AlternatesFSM_startWhenTheActionRelease";
			type := seqOfRelationDeclaration->select(rd | rd.name = "AlternatesFSM")->first();
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.triggers.oclAsType(VarRef).variable->select(t| t.oclIsKindOf(Action))->first().oclAsType(Action).oclAsType(EObject))+'_releases']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesFSM_left']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_synchronousExecution']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesFSM_right']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	

//Create an intermediate relation
	mapping inMM2::Reaction::intermediate_UpdatesOutVarAllTogether22UpdatesOutVarAllTogether(an1 : Variable, an2 : Variable, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_UpdatesOutVarAllTogether'+nbi.toString()+"_"+nbj.toString();
		var seqAbstract : Sequence(Stdlib::Element) := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Coincidence).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence();
		type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
		
		

					bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_updates']->first();
						_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;

				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_updates']->first();
						_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;

				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM2::Reaction::UpdatesOutVarAllTogether22UpdatesOutVarAllTogether()
			when { 
				
				(self.effects->size() > 1) 
			}
	{
		init{
			
			
			var sources : Sequence(Variable) := self.effects.variable->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_UpdatesOutVarAllTogether22UpdatesOutVarAllTogether(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		
	
		mapping inMM2::Reaction::UpdatesOutVarOnExecute22UpdatesOutVarOnExecute(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				
				-- for now consider a single effect 
		(self.effects->size()  > 0
--			and
--		 not self.effects->first().oclIsKindOf(Action)
		) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_UpdatesOutVarOnExecute";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
			
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.effects.variable->first().oclAsType(EObject))+'_updates']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_synchronousExecution']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		





















mapping inMM2::Model::ecore2FeedBack() : FeedBack::ActionModel {
	    theFeedBackSpec := result;
		importStatements+= object FeedBack::ImportStatement{
			importURI := getModelPath(ccsl.objectsOfType(TimeModel::Clock)->asSequence()->first().oclAsType(EObject));
		}; 
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map timeJump2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map untimedAction2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map allTimerAndActionRelease2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map allCanRelease2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map allWait2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Instantiation.oclAsType(EClass)).oclAsType(Instantiation)->map startExecuting2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Instantiation.oclAsType(EClass)).oclAsType(Instantiation)->map finishExecuting2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Reactor.oclAsType(EClass)).oclAsType(Reactor)->map startExecuting2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Reactor.oclAsType(EClass)).oclAsType(Reactor)->map finishExecuting2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Reaction.oclAsType(EClass)).oclAsType(Reaction)->map synchronousExecution2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Variable.oclAsType(EClass)).oclAsType(Variable)->map updates2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Timer.oclAsType(EClass)).oclAsType(Timer)->map starts2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Timer.oclAsType(EClass)).oclAsType(Timer)->map releases2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Timer.oclAsType(EClass)).oclAsType(Timer)->map wait2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Timer.oclAsType(EClass)).oclAsType(Timer)->map canRelease2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Timer.oclAsType(EClass)).oclAsType(Timer)->map canRelease12ActionFeedBack();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Timer.oclAsType(EClass)).oclAsType(Timer)->map canRelease22ActionFeedBack();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map starts2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map releases2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map wait2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map canRelease2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map canRelease12ActionFeedBack();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map canRelease22ActionFeedBack();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Connection.oclAsType(EClass)).oclAsType(Connection)->map starts2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Connection.oclAsType(EClass)).oclAsType(Connection)->map releases2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Connection.oclAsType(EClass)).oclAsType(Connection)->map wait2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Connection.oclAsType(EClass)).oclAsType(Connection)->map canRelease2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Connection.oclAsType(EClass)).oclAsType(Connection)->map canRelease12ActionFeedBack();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Connection.oclAsType(EClass)).oclAsType(Connection)->map canRelease22ActionFeedBack();
}		


	 	mapping inMM2::Model::timeJump2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_timeJump';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "timeJump")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_timeJump')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM2::Model::untimedAction2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_untimedAction';

				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_untimedAction')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM2::Model::allTimerAndActionRelease2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_allTimerAndActionRelease';

				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_allTimerAndActionRelease')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM2::Model::allCanRelease2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_allCanRelease';

				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_allCanRelease')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM2::Model::allWait2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_allWait';

				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_allWait')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM2::Instantiation::startExecuting2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_startExecuting';

				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_startExecuting')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM2::Instantiation::finishExecuting2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_finishExecuting';

				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_finishExecuting')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM2::Reactor::startExecuting2MSE() :FeedBack::ModelSpecificEvent 
			when { (self._main) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_startExecuting';

				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_startExecuting')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM2::Reactor::finishExecuting2MSE() :FeedBack::ModelSpecificEvent 
			when { (self._main) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_finishExecuting';

				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_finishExecuting')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM2::Reaction::synchronousExecution2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_synchronousExecution';

				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_synchronousExecution')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM2::Variable::updates2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_updates';

				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_updates')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM2::Timer::starts2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_starts';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "schedule")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_starts')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM2::Timer::releases2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_releases';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "release")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_releases')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM2::Timer::wait2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_wait';

				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_wait')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM2::Timer::canRelease2MSE() :FeedBack::ModelSpecificEvent 
			when { (true) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_canRelease';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "canTick")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_canRelease')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM2::Action::starts2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_starts';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "schedule")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_starts')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM2::Action::releases2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_releases';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "release")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_releases')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM2::Action::wait2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.minDelay <> null and self.minDelay.time <> null) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_wait';

				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_wait')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM2::Action::canRelease2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.minDelay <> null and self.minDelay.time <> null) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_canRelease';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "canTick")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_canRelease')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM2::Connection::starts2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.delay <> null and self.delay.time <> null) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_starts';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "schedule")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_starts')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM2::Connection::releases2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.delay <> null and self.delay.time <> null) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_releases';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "release")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_releases')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM2::Connection::wait2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.delay <> null and self.delay.time <> null) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_wait';

				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_wait')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM2::Connection::canRelease2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.delay <> null and self.delay.time <> null) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_canRelease';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "canTick")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_canRelease')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
			
		


		mapping inMM2::Timer::canRelease12ActionFeedBack() :FeedBack::When 
			when { (true) }
		{
			action := object FeedBack::Force{
				kind := ForceKind::Presence;
				eventToBeForced := seqOfMSE->select(mse | mse.name = 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_releases')->first();
				
			};
			condition := object FeedBack::ActionResultCondition{
				operator := ComparisonOperator::equals;
				comparisonValue := true;
			};
			source := seqOfMSE->select(mse | mse.name = 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_canRelease')->first();
			
			end{
				theFeedBackSpec.whenStatements += result;
			}

		}
		mapping inMM2::Timer::canRelease22ActionFeedBack() :FeedBack::When 
			when { (true) }
		{
			action := object FeedBack::Force{
				kind := ForceKind::Presence;
				eventToBeForced := seqOfMSE->select(mse | mse.name = 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_wait')->first();
				
			};
			condition := object FeedBack::ActionResultCondition{
				operator := ComparisonOperator::equals;
				comparisonValue := false;
			};
			source := seqOfMSE->select(mse | mse.name = 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_canRelease')->first();
			
			end{
				theFeedBackSpec.whenStatements += result;
			}

		}
		mapping inMM2::Action::canRelease12ActionFeedBack() :FeedBack::When 
			when { (self.minDelay <> null and self.minDelay.time <> null) }
		{
			action := object FeedBack::Force{
				kind := ForceKind::Presence;
				eventToBeForced := seqOfMSE->select(mse | mse.name = 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_releases')->first();
				
			};
			condition := object FeedBack::ActionResultCondition{
				operator := ComparisonOperator::equals;
				comparisonValue := true;
			};
			source := seqOfMSE->select(mse | mse.name = 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_canRelease')->first();
			
			end{
				theFeedBackSpec.whenStatements += result;
			}

		}
		mapping inMM2::Action::canRelease22ActionFeedBack() :FeedBack::When 
			when { (self.minDelay <> null and self.minDelay.time <> null) }
		{
			action := object FeedBack::Force{
				kind := ForceKind::Presence;
				eventToBeForced := seqOfMSE->select(mse | mse.name = 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_wait')->first();
				
			};
			condition := object FeedBack::ActionResultCondition{
				operator := ComparisonOperator::equals;
				comparisonValue := false;
			};
			source := seqOfMSE->select(mse | mse.name = 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_canRelease')->first();
			
			end{
				theFeedBackSpec.whenStatements += result;
			}

		}
		mapping inMM2::Connection::canRelease12ActionFeedBack() :FeedBack::When 
			when { (self.delay <> null and self.delay.time <> null) }
		{
			action := object FeedBack::Force{
				kind := ForceKind::Presence;
				eventToBeForced := seqOfMSE->select(mse | mse.name = 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_releases')->first();
				
			};
			condition := object FeedBack::ActionResultCondition{
				operator := ComparisonOperator::equals;
				comparisonValue := true;
			};
			source := seqOfMSE->select(mse | mse.name = 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_canRelease')->first();
			
			end{
				theFeedBackSpec.whenStatements += result;
			}

		}
		mapping inMM2::Connection::canRelease22ActionFeedBack() :FeedBack::When 
			when { (self.delay <> null and self.delay.time <> null) }
		{
			action := object FeedBack::Force{
				kind := ForceKind::Presence;
				eventToBeForced := seqOfMSE->select(mse | mse.name = 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_wait')->first();
				
			};
			condition := object FeedBack::ActionResultCondition{
				operator := ComparisonOperator::equals;
				comparisonValue := false;
			};
			source := seqOfMSE->select(mse | mse.name = 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_canRelease')->first();
			
			end{
				theFeedBackSpec.whenStatements += result;
			}

		}




//priority stuff

mapping inMM2::Model::ecore2Priority()  :Priority::PrioritySpecification  {
	thePrioritySpec := result;
	importedModel := object Priority::ImportStatement{
		importURI := getModelPath(ccsl.objectsOfType(TimeModel::Clock)->asSequence()->first().oclAsType(EObject));
	}; 
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map untimedPriorTimed12untimedPriorTimed();
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map releasePriorUntimed12releasePriorUntimed();
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map canReleasePriorUntimed12canReleasePriorUntimed();
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map canReleasePriorRelease12canReleasePriorRelease();
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Model.oclAsType(EClass)).oclAsType(Model)->map canReleasePriorWait12canReleasePriorWait();
}	

		mapping inMM2::Model::untimedPriorTimed12untimedPriorTimed() :Priority::PriorityRelation 
		{
			lower  := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_timeJump']->first();
			higher := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_untimedAction']->first();
			end{
				thePrioritySpec.relations += result;
			}
		}
		mapping inMM2::Model::releasePriorUntimed12releasePriorUntimed() :Priority::PriorityRelation 
		{
			lower  := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_untimedAction']->first();
			higher := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_allTimerAndActionRelease']->first();
			end{
				thePrioritySpec.relations += result;
			}
		}
		mapping inMM2::Model::canReleasePriorUntimed12canReleasePriorUntimed() :Priority::PriorityRelation 
		{
			lower  := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_allTimerAndActionRelease']->first();
			higher := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_allCanRelease']->first();
			end{
				thePrioritySpec.relations += result;
			}
		}
		mapping inMM2::Model::canReleasePriorRelease12canReleasePriorRelease() :Priority::PriorityRelation 
		{
			lower  := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_allTimerAndActionRelease']->first();
			higher := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_allCanRelease']->first();
			end{
				thePrioritySpec.relations += result;
			}
		}
		mapping inMM2::Model::canReleasePriorWait12canReleasePriorWait() :Priority::PriorityRelation 
		{
			lower  := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_allWait']->first();
			higher := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_allCanRelease']->first();
			end{
				thePrioritySpec.relations += result;
			}
		}



